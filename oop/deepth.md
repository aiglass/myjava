### 深入分析类与对象
类的属性和方法，一般方法对外提供服务的不进行封装处理，而属性具有较高的安全行，所以往往需要对属性进行封装以进行保护。
#### 成员属性封装
默认情况下，类中的属性可以通过其他类利用对象进行调用。

属性不封装的问题：
-   外部直接调用，可能设置错误的数据

封装处理
-   利用private关键字封装，对外部不可见，报错The field Person.name is not visible
-   java开发标准中用【setter、getter】方法进行赋值和取出
-   在以后任何类的定义的时候，都要用private封装（98%）。
-   对属性的获取，一定要提供setter、getter

#### 构造方法和匿名对象
假设：类有多个属性，在实例话对象的过程中需要调用多次的setter方法。如何解决？（构造方法）

##### 构造方法
<kbd>可以通过构造方法实例化对象中的属性初始化处理</kbd>只有在关键字new的时候会调用构造方法
-   构造方法名称必须与类名称保持一致
-   构造方法不允许设置任何的返回值类型，即没有返回值定义
-   构造方法是在使用关键字new实例化对象的时候自动调用的

实例化对象格式对比。
-   普通：Person per=new Person()
-   构造方法：Person per=new Person(参数1，参数2...)
-   java对所有类实例化时创建一个无参的构造方法
-   自写构造方法后，实例化时使用自定义的构造方法
-   一个类中至少会存在一个构造方法

思考🤔？为什么构造方法不能定义返回值类型？为什么构造方法没有void定义呢？
-   java编译器是根据代码结构进行编译的
-   java执行时也是根据代码结构进行执行的
-   如果构造方法有void时，则编译器无法识别构造方法
-   构造方法也可以进行重载，重载时只需要考虑参数个数与类型
-   在定义过个构造方法重载时，使用一定的顺序排列。例：参数个数

构造方法操作属性与getter、setter的区别
-   构造方法是在实例化对象时进行属性的初始化
-   getter、setter是在实例化之后进行属性的修改
-   getter、setter在实例化以后依然可以对属性进行操作

思考？利用构造方法可以传递属性数据，进一步分析对象的产生格式
-   定义对象名称：类名称 对象名称=null;
-   实例话对象：对象名称=[new 类名称()];[]内为真实对象
-   直接使用[new 类名称()]进行实例化，也可以进行操作。又叫**匿名对象**。使用一次后就成为了垃圾，被GC收集与释放。
-   只要是方法就可以传递任意数据类型包括基本数据类型、引用数据类型
-   任何实例化对象都可以被引用，包括匿名对象
